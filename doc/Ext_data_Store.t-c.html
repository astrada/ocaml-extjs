<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="css/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Ext_data_Store.configs-c.html">
<link rel="Up" href="Ext_data_Store.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Ext" rel="Chapter" href="Ext.html">
<link title="Ext_AbstractComponent" rel="Chapter" href="Ext_AbstractComponent.html">
<link title="Ext_AbstractPlugin" rel="Chapter" href="Ext_AbstractPlugin.html">
<link title="Ext_app_Application" rel="Chapter" href="Ext_app_Application.html">
<link title="Ext_app_Controller" rel="Chapter" href="Ext_app_Controller.html">
<link title="Ext_Base" rel="Chapter" href="Ext_Base.html">
<link title="Ext_button_Button" rel="Chapter" href="Ext_button_Button.html">
<link title="Ext_Class" rel="Chapter" href="Ext_Class.html">
<link title="Ext_Component" rel="Chapter" href="Ext_Component.html">
<link title="Ext_ComponentLoader" rel="Chapter" href="Ext_ComponentLoader.html">
<link title="Ext_container_AbstractContainer" rel="Chapter" href="Ext_container_AbstractContainer.html">
<link title="Ext_container_Container" rel="Chapter" href="Ext_container_Container.html">
<link title="Ext_container_DockingContainer" rel="Chapter" href="Ext_container_DockingContainer.html">
<link title="Ext_container_Viewport" rel="Chapter" href="Ext_container_Viewport.html">
<link title="Ext_data_AbstractStore" rel="Chapter" href="Ext_data_AbstractStore.html">
<link title="Ext_data_Batch" rel="Chapter" href="Ext_data_Batch.html">
<link title="Ext_data_Errors" rel="Chapter" href="Ext_data_Errors.html">
<link title="Ext_data_Field" rel="Chapter" href="Ext_data_Field.html">
<link title="Ext_data_Model" rel="Chapter" href="Ext_data_Model.html">
<link title="Ext_data_Operation" rel="Chapter" href="Ext_data_Operation.html">
<link title="Ext_data_proxy_Ajax" rel="Chapter" href="Ext_data_proxy_Ajax.html">
<link title="Ext_data_proxy_Proxy" rel="Chapter" href="Ext_data_proxy_Proxy.html">
<link title="Ext_data_proxy_Server" rel="Chapter" href="Ext_data_proxy_Server.html">
<link title="Ext_data_reader_Reader" rel="Chapter" href="Ext_data_reader_Reader.html">
<link title="Ext_data_Request" rel="Chapter" href="Ext_data_Request.html">
<link title="Ext_data_ResultSet" rel="Chapter" href="Ext_data_ResultSet.html">
<link title="Ext_data_Store" rel="Chapter" href="Ext_data_Store.html">
<link title="Ext_data_writer_Writer" rel="Chapter" href="Ext_data_writer_Writer.html">
<link title="Ext_dd_DD" rel="Chapter" href="Ext_dd_DD.html">
<link title="Ext_dd_DDProxy" rel="Chapter" href="Ext_dd_DDProxy.html">
<link title="Ext_dd_DDTarget" rel="Chapter" href="Ext_dd_DDTarget.html">
<link title="Ext_dd_DragDrop" rel="Chapter" href="Ext_dd_DragDrop.html">
<link title="Ext_dd_DragSource" rel="Chapter" href="Ext_dd_DragSource.html">
<link title="Ext_dd_DragTracker" rel="Chapter" href="Ext_dd_DragTracker.html">
<link title="Ext_dd_StatusProxy" rel="Chapter" href="Ext_dd_StatusProxy.html">
<link title="Ext_dom_AbstractElement" rel="Chapter" href="Ext_dom_AbstractElement.html">
<link title="Ext_dom_AbstractElement_Fly" rel="Chapter" href="Ext_dom_AbstractElement_Fly.html">
<link title="Ext_dom_Element" rel="Chapter" href="Ext_dom_Element.html">
<link title="Ext_ElementLoader" rel="Chapter" href="Ext_ElementLoader.html">
<link title="Ext_Error" rel="Chapter" href="Ext_Error.html">
<link title="Ext_EventObject" rel="Chapter" href="Ext_EventObject.html">
<link title="Ext_form_action_Action" rel="Chapter" href="Ext_form_action_Action.html">
<link title="Ext_form_Basic" rel="Chapter" href="Ext_form_Basic.html">
<link title="Ext_form_FieldAncestor" rel="Chapter" href="Ext_form_FieldAncestor.html">
<link title="Ext_form_field_Base" rel="Chapter" href="Ext_form_field_Base.html">
<link title="Ext_form_field_Field" rel="Chapter" href="Ext_form_field_Field.html">
<link title="Ext_form_field_Text" rel="Chapter" href="Ext_form_field_Text.html">
<link title="Ext_form_Labelable" rel="Chapter" href="Ext_form_Labelable.html">
<link title="Ext_form_Panel" rel="Chapter" href="Ext_form_Panel.html">
<link title="Ext_grid_column_Column" rel="Chapter" href="Ext_grid_column_Column.html">
<link title="Ext_grid_feature_Feature" rel="Chapter" href="Ext_grid_feature_Feature.html">
<link title="Ext_grid_header_Container" rel="Chapter" href="Ext_grid_header_Container.html">
<link title="Ext_grid_Panel" rel="Chapter" href="Ext_grid_Panel.html">
<link title="Ext_grid_plugin_Editing" rel="Chapter" href="Ext_grid_plugin_Editing.html">
<link title="Ext_grid_View" rel="Chapter" href="Ext_grid_View.html">
<link title="Ext_layout_container_Container" rel="Chapter" href="Ext_layout_container_Container.html">
<link title="Ext_layout_ContextItem" rel="Chapter" href="Ext_layout_ContextItem.html">
<link title="Ext_layout_Layout" rel="Chapter" href="Ext_layout_Layout.html">
<link title="Ext_Loader" rel="Chapter" href="Ext_Loader.html">
<link title="Ext_menu_Menu" rel="Chapter" href="Ext_menu_Menu.html">
<link title="Ext_panel_AbstractPanel" rel="Chapter" href="Ext_panel_AbstractPanel.html">
<link title="Ext_panel_Panel" rel="Chapter" href="Ext_panel_Panel.html">
<link title="Ext_panel_Table" rel="Chapter" href="Ext_panel_Table.html">
<link title="Ext_selection_DataViewModel" rel="Chapter" href="Ext_selection_DataViewModel.html">
<link title="Ext_selection_Model" rel="Chapter" href="Ext_selection_Model.html">
<link title="Ext_selection_RowModel" rel="Chapter" href="Ext_selection_RowModel.html">
<link title="Ext_state_Manager" rel="Chapter" href="Ext_state_Manager.html">
<link title="Ext_state_Provider" rel="Chapter" href="Ext_state_Provider.html">
<link title="Ext_state_Stateful" rel="Chapter" href="Ext_state_Stateful.html">
<link title="Ext_Template" rel="Chapter" href="Ext_Template.html">
<link title="Ext_tip_QuickTip" rel="Chapter" href="Ext_tip_QuickTip.html">
<link title="Ext_tip_QuickTipManager" rel="Chapter" href="Ext_tip_QuickTipManager.html">
<link title="Ext_tip_Tip" rel="Chapter" href="Ext_tip_Tip.html">
<link title="Ext_tip_ToolTip" rel="Chapter" href="Ext_tip_ToolTip.html">
<link title="Ext_util_AbstractMixedCollection" rel="Chapter" href="Ext_util_AbstractMixedCollection.html">
<link title="Ext_util_Animate" rel="Chapter" href="Ext_util_Animate.html">
<link title="Ext_util_Bindable" rel="Chapter" href="Ext_util_Bindable.html">
<link title="Ext_util_ComponentDragger" rel="Chapter" href="Ext_util_ComponentDragger.html">
<link title="Ext_util_ElementContainer" rel="Chapter" href="Ext_util_ElementContainer.html">
<link title="Ext_util_Filter" rel="Chapter" href="Ext_util_Filter.html">
<link title="Ext_util_Floating" rel="Chapter" href="Ext_util_Floating.html">
<link title="Ext_util_Format" rel="Chapter" href="Ext_util_Format.html">
<link title="Ext_util_Grouper" rel="Chapter" href="Ext_util_Grouper.html">
<link title="Ext_util_KeyMap" rel="Chapter" href="Ext_util_KeyMap.html">
<link title="Ext_util_MixedCollection" rel="Chapter" href="Ext_util_MixedCollection.html">
<link title="Ext_util_Observable" rel="Chapter" href="Ext_util_Observable.html">
<link title="Ext_util_Offset" rel="Chapter" href="Ext_util_Offset.html">
<link title="Ext_util_Point" rel="Chapter" href="Ext_util_Point.html">
<link title="Ext_util_Region" rel="Chapter" href="Ext_util_Region.html">
<link title="Ext_util_Renderable" rel="Chapter" href="Ext_util_Renderable.html">
<link title="Ext_util_Sortable" rel="Chapter" href="Ext_util_Sortable.html">
<link title="Ext_util_Sorter" rel="Chapter" href="Ext_util_Sorter.html">
<link title="Ext_Version" rel="Chapter" href="Ext_Version.html">
<link title="Ext_view_AbstractView" rel="Chapter" href="Ext_view_AbstractView.html">
<link title="Ext_view_Table" rel="Chapter" href="Ext_view_Table.html">
<link title="Ext_view_View" rel="Chapter" href="Ext_view_View.html">
<link title="Ext_window_MessageBox" rel="Chapter" href="Ext_window_MessageBox.html">
<link title="Ext_window_Window" rel="Chapter" href="Ext_window_Window.html">
<link title="Ext_ZIndexManager" rel="Chapter" href="Ext_ZIndexManager.html">
<link title="ExtUtils" rel="Chapter" href="ExtUtils.html"><title>Ext_data_Store.t</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Ext_data_Store.html">Up</a>
&nbsp;<a href="Ext_data_Store.configs-c.html">Next</a>
</div>
<center><h1>Class type <a href="type_Ext_data_Store.t.html">Ext_data_Store.t</a></h1></center>
<br>
<pre><span id="TYPEt"><span class="keyword">class type</span> t</span> = <code class="code">object</code> <a href="Ext_data_Store.t-c.html">..</a> <code class="code">end</code></pre><b>Inherits</b><ul>
<li><a href="Ext_Base.t-c.html"><code class="code">Ext_Base.t</code></a></li>
<li><a href="Ext_data_AbstractStore.t-c.html"><code class="code">Ext_data_AbstractStore.t</code></a></li>
</ul>
<hr width="100%">
<pre><span id="METHODcurrentPage"><span class="keyword">method</span> currentPage</span> : <code class="type">Js.number Js.t Js.prop</code></pre><div class="info">
<p>The page that the Store has most recently loaded (see <a href="#!/api/Ext.data.Store-method-loadPage" rel="Ext.data.Store-method-loadPage" class="docClass">loadPage</a>)</p> 
<p>

    Defaults to: <code class="code">1</code><br>
</div>
<pre><span id="METHODdata"><span class="keyword">method</span> data</span> : <code class="type"><a href="Ext_util_MixedCollection.t-c.html">Ext_util_MixedCollection.t</a> Js.t Js.prop</code></pre><div class="info">
<p>The MixedCollection that holds this store's local cache of records.</p> <br>
</div>
<pre><span id="METHODgroupers"><span class="keyword">method</span> groupers</span> : <code class="type"><a href="Ext_util_MixedCollection.t-c.html">Ext_util_MixedCollection.t</a> Js.t Js.prop</code></pre><div class="info">
<p>The collection of <a href="#!/api/Ext.util.Grouper" rel="Ext.util.Grouper" class="docClass">Groupers</a> currently applied to this Store.</p> <br>
</div>
<pre><span id="METHODsnapshot"><span class="keyword">method</span> snapshot</span> : <code class="type"><a href="Ext_util_MixedCollection.t-c.html">Ext_util_MixedCollection.t</a> Js.t Js.prop</code></pre><div class="info">
<p>A pristine (unfiltered) collection of the records in this store. This is used to reinstate
records when a filter is removed or changed</p> <br>
</div>
<pre><span id="METHODadd"><span class="keyword">method</span> add</span> : <code class="type">'a. 'a Js.t -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>Adds Model instance to the Store. This method accepts either:</p>

<ul>
<li>An array of Model instances or Model configuration objects.</li>
<li>Any number of Model instance or Model configuration object arguments.</li>
</ul>


<p>The new Model instances will be added at the end of the existing collection.</p>

<p>Sample usage:</p>

<pre><code>myStore.add({some: 'data'}, {some: 'other data'});
</code></pre>

<p>Note that if this Store is sorted, the new Model instances will be inserted
at the correct point in the Store to maintain the sort order.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>model: <code class="code">_ Js.t</code>
    <p>An array of Model instances
or Model configuration objects, or variable number of Model instance or config arguments.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>The model instances that were added</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODaddSorted"><span class="keyword">method</span> addSorted</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t -> unit Js.meth</code></pre><div class="info">
<p>(Local sort only) Inserts the passed Record into the Store at the index where it
should go based on the current sort information.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>record: <code class="code">Ext_data_Model.t Js.t</code>
    </li>
</ul>
<br>
</div>
<pre><span id="METHODaggregate"><span class="keyword">method</span> aggregate</span> : <code class="type">'b 'c 'd 'e.<br>         'b Js.callback -><br>         'c Js.t Js.optdef -><br>         bool Js.t Js.optdef -> 'd Js.js_array Js.t Js.optdef -> 'e Js.t Js.meth</code></pre><div class="info">
<p>Runs the aggregate function for all the records in the store.</p>

<p>When store is filtered, only items within the filter are aggregated.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fn: <code class="code">_ Js.callback</code>
    <p>The function to execute. The function is called with a single parameter,
an array of records for that group.</p> 
    </li>
<li>scope: <code class="code">_ Js.t</code> (optional)
    <p>The scope to execute the function in. Defaults to the store.</p> 
    </li>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the group average being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
<li>args: <code class="code">_ Js.js_array Js.t</code> (optional)
    <p>Any arguments to append to the function call</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code>
    <p>An object literal with the group names and their appropriate values.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODaverage"><span class="keyword">method</span> average</span> : <code class="type">'f. Js.js_string Js.t -> bool Js.t Js.optdef -> 'f Js.t Js.meth</code></pre><div class="info">
<p>Gets the average value in the store.</p>

<p>When store is filtered, only items within the filter are aggregated.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>field: <code class="code">Js.js_string Js.t</code>
    <p>The field in each record</p> 
    </li>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the group average being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code> <p>The average value, if no items exist, 0.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODclearFilter"><span class="keyword">method</span> clearFilter</span> : <code class="type">bool Js.t -> unit Js.meth</code></pre><div class="info">
<p>Reverts to a view of the Record cache with no filtering applied.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>suppressEvent: <code class="code">bool Js.t</code>
    <p>If <code>true</code> the filter is cleared silently.</p>

<p>For a locally filtered Store, this means that the filter collection is cleared without firing the
<a href="#!/api/Ext.data.Store-event-datachanged" rel="Ext.data.Store-event-datachanged" class="docClass">datachanged</a> event.</p>

<p>For a remotely filtered Store, this means that the filter collection is cleared, but the store
is not reloaded from the server.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODclearGrouping"><span class="keyword">method</span> clearGrouping</span> : <code class="type">unit Js.meth</code></pre><div class="info">
<p>Clear any groupers in the store</p> <br>
</div>
<pre><span id="METHODcollect"><span class="keyword">method</span> collect</span> : <code class="type">'g.<br>         Js.js_string Js.t -><br>         bool Js.t Js.optdef -><br>         bool Js.t Js.optdef -> 'g Js.t Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>Collects unique values for a particular dataIndex from this store.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>dataIndex: <code class="code">Js.js_string Js.t</code>
    <p>The property to collect</p> 
    </li>
<li>allowNull: <code class="code">bool Js.t</code> (optional)
    <p>Pass true to allow null, undefined or empty string values</p> 
    </li>
<li>bypassFilter: <code class="code">bool Js.t</code> (optional)
    <p>Pass true to collect from all records, even ones which are filtered.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t Js.js_array Js.t</code>
    <p>An array of the unique values</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODcommitChanges"><span class="keyword">method</span> commitChanges</span> : <code class="type">unit Js.meth</code></pre><div class="info">
<p>Commits all Records with <a href="#!/api/Ext.data.Store-method-getModifiedRecords" rel="Ext.data.Store-method-getModifiedRecords" class="docClass">outstanding changes</a>. To handle updates for changes,
subscribe to the Store's <a href="#!/api/Ext.data.Store-event-update" rel="Ext.data.Store-event-update" class="docClass">update event</a>, and perform updating when the third parameter is
<a href="#!/api/Ext.data.Model-static-property-COMMIT" rel="Ext.data.Model-static-property-COMMIT" class="docClass">Ext.data.Record.COMMIT</a>.</p> <br>
</div>
<pre><span id="METHODcount"><span class="keyword">method</span> count</span> : <code class="type">bool Js.t Js.optdef -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Gets the count of items in the store.</p>

<p>When store is filtered, only items within the filter are counted.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the count for each group being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>the count</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODeach"><span class="keyword">method</span> each</span> : <code class="type">'h 'i. 'h Js.callback -> 'i Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Calls the specified function for each <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">record</a> in the store.</p>

<p>When store is filtered, only loops over the filtered records.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fn: <code class="code">_ Js.callback</code>
    <p>The function to call. The <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Record</a> is passed as the first parameter.
Returning <code>false</code> aborts and exits the iteration.</p> 
    </li>
<li>scope: <code class="code">_ Js.t</code> (optional)
    <p>The scope (this reference) in which the function is executed.
Defaults to the current <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">record</a> in the iteration.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfilter"><span class="keyword">method</span> filter</span> : <code class="type">'j. 'j Js.t -> Js.js_string Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Filters the loaded set of records by a given set of filters.</p>

<p>By default, the passed filter(s) are <em>added</em> to the collection of filters being used to filter this Store.</p>

<p>To remove existing filters before applying a new set of filters use</p>

<pre><code>// Clear the filter collection without updating the UI
store.clearFilter(true);
</code></pre>

<p>see <a href="#!/api/Ext.data.Store-method-clearFilter" rel="Ext.data.Store-method-clearFilter" class="docClass">clearFilter</a>.</p>

<p>Alternatively, if filters are configured with an <code>id</code>, then existing filters store may be <em>replaced</em> by new
filters having the same <code>id</code>.</p>

<p>Filtering by single field:</p>

<pre><code>store.filter("email", /\.com$/);
</code></pre>

<p>Using multiple filters:</p>

<pre><code>store.filter([
    {property: "email", value: /\.com$/},
    {filterFn: function(item) { return item.get("age") &gt; 10; }}
]);
</code></pre>

<p>Using <a href="#!/api/Ext.util.Filter" rel="Ext.util.Filter" class="docClass">Ext.util.Filter</a> instances instead of config objects
(note that we need to specify the <a href="#!/api/Ext.util.Filter-cfg-root" rel="Ext.util.Filter-cfg-root" class="docClass">root</a> config option in this case):</p>

<pre><code>store.filter([
    <a href="#!/api/Ext-method-create" rel="Ext-method-create" class="docClass">Ext.create</a>('<a href="#!/api/Ext.util.Filter" rel="Ext.util.Filter" class="docClass">Ext.util.Filter</a>', {property: "email", value: /\.com$/, root: 'data'}),
    <a href="#!/api/Ext-method-create" rel="Ext-method-create" class="docClass">Ext.create</a>('<a href="#!/api/Ext.util.Filter" rel="Ext.util.Filter" class="docClass">Ext.util.Filter</a>', {filterFn: function(item) { return item.get("age") &gt; 10; }, root: 'data'})
]);
</code></pre>

<p>When store is filtered, most of the methods for accessing store data will be working only
within the set of filtered records. Two notable exceptions are <a href="#!/api/Ext.data.Store-method-queryBy" rel="Ext.data.Store-method-queryBy" class="docClass">queryBy</a> and
<a href="#!/api/Ext.data.Store-method-getById" rel="Ext.data.Store-method-getById" class="docClass">getById</a>.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>filters: <code class="code">_ Js.t</code>
    <p>The set of filters to apply to the data.
These are stored internally on the store, but the filtering itself is done on the Store's
<a href="#!/api/Ext.util.MixedCollection" rel="Ext.util.MixedCollection" class="docClass">MixedCollection</a>. See MixedCollection's
<a href="#!/api/Ext.util.MixedCollection-method-filter" rel="Ext.util.MixedCollection-method-filter" class="docClass">filter</a> method for filter syntax.
Alternatively, pass in a property string</p> 
    </li>
<li>value: <code class="code">Js.js_string Js.t</code> (optional)
    <p>value to filter by (only if using a property string as the first argument)</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfilterBy"><span class="keyword">method</span> filterBy</span> : <code class="type">'k 'l. 'k Js.callback -> 'l Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Filters by a function. The specified function will be called for each
Record in this Store. If the function returns <code>true</code> the Record is included,
otherwise it is filtered out.</p>

<p>When store is filtered, most of the methods for accessing store data will be working only
within the set of filtered records. Two notable exceptions are <a href="#!/api/Ext.data.Store-method-queryBy" rel="Ext.data.Store-method-queryBy" class="docClass">queryBy</a> and
<a href="#!/api/Ext.data.Store-method-getById" rel="Ext.data.Store-method-getById" class="docClass">getById</a>.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fn: <code class="code">_ Js.callback</code>
    <p>The function to be called. It will be passed the following parameters:</p> 
    </li>
<li>scope: <code class="code">_ Js.t</code> (optional)
    <p>The scope (this reference) in which the function is executed.
Defaults to this Store.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfind"><span class="keyword">method</span> find</span> : <code class="type">'m.<br>         Js.js_string Js.t -><br>         'm Js.t -><br>         Js.number Js.t Js.optdef -><br>         bool Js.t Js.optdef -><br>         bool Js.t Js.optdef -> bool Js.t Js.optdef -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Finds the index of the first matching Record in this store by a specific field value.</p>

<p>When store is filtered, finds records only within filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fieldName: <code class="code">Js.js_string Js.t</code>
    <p>The name of the Record field to test.</p> 
    </li>
<li>value: <code class="code">_ Js.t</code>
    <p>Either a string that the field value
should begin with, or a RegExp to test against the field.</p> 
    </li>
<li>startIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The index to start searching at</p> 
     Defaults to: 0
    </li>
<li>anyMatch: <code class="code">bool Js.t</code> (optional)
    <p>True to match any part of the string, not just the beginning</p> 
     Defaults to: false
    </li>
<li>caseSensitive: <code class="code">bool Js.t</code> (optional)
    <p>True for case sensitive comparison</p> 
     Defaults to: false
    </li>
<li>exactMatch: <code class="code">bool Js.t</code> (optional)
    <p>True to force exact match (^ and $ characters added to the regex).</p> 
     Defaults to: false
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>The matched index or -1</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfindBy"><span class="keyword">method</span> findBy</span> : <code class="type">'n 'o.<br>         'n Js.callback -><br>         'o Js.t Js.optdef -> Js.number Js.t Js.optdef -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Find the index of the first matching Record in this Store by a function.
If the function returns <code>true</code> it is considered a match.</p>

<p>When store is filtered, finds records only within filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fn: <code class="code">_ Js.callback</code>
    <p>The function to be called. It will be passed the following parameters:</p> 
    </li>
<li>scope: <code class="code">_ Js.t</code> (optional)
    <p>The scope (this reference) in which the function is executed.
Defaults to this Store.</p> 
    </li>
<li>startIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The index to start searching at</p> 
     Defaults to: 0
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>The matched index or -1</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfindExact"><span class="keyword">method</span> findExact</span> : <code class="type">'p.<br>         Js.js_string Js.t -><br>         'p Js.t -> Js.number Js.t Js.optdef -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Finds the index of the first matching Record in this store by a specific field value.</p>

<p>When store is filtered, finds records only within filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fieldName: <code class="code">Js.js_string Js.t</code>
    <p>The name of the Record field to test.</p> 
    </li>
<li>value: <code class="code">_ Js.t</code>
    <p>The value to match the field against.</p> 
    </li>
<li>startIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The index to start searching at</p> 
     Defaults to: 0
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>The matched index or -1</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfindRecord"><span class="keyword">method</span> findRecord</span> : <code class="type">'q.<br>         Js.js_string Js.t -><br>         'q Js.t -><br>         Js.number Js.t Js.optdef -><br>         bool Js.t Js.optdef -><br>         bool Js.t Js.optdef -> bool Js.t Js.optdef -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t Js.meth</code></pre><div class="info">
<p>Finds the first matching Record in this store by a specific field value.</p>

<p>When store is filtered, finds records only within filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fieldName: <code class="code">Js.js_string Js.t</code>
    <p>The name of the Record field to test.</p> 
    </li>
<li>value: <code class="code">_ Js.t</code>
    <p>Either a string that the field value
should begin with, or a RegExp to test against the field.</p> 
    </li>
<li>startIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The index to start searching at</p> 
     Defaults to: 0
    </li>
<li>anyMatch: <code class="code">bool Js.t</code> (optional)
    <p>True to match any part of the string, not just the beginning</p> 
     Defaults to: false
    </li>
<li>caseSensitive: <code class="code">bool Js.t</code> (optional)
    <p>True for case sensitive comparison</p> 
     Defaults to: false
    </li>
<li>exactMatch: <code class="code">bool Js.t</code> (optional)
    <p>True to force exact match (^ and $ characters added to the regex).</p> 
     Defaults to: false
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.t</code>
    <p>The matched record or null</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODfirst"><span class="keyword">method</span> first</span> : <code class="type">'r. bool Js.t Js.optdef -> 'r Js.t Js.meth</code></pre><div class="info">
<p>Convenience function for getting the first model instance in the store.</p>

<p>When store is filtered, will return first item within the filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the first record being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code>
    <p>The first model instance in the store, or undefined</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetAt"><span class="keyword">method</span> getAt</span> : <code class="type">Js.number Js.t -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t Js.meth</code></pre><div class="info">
<p>Get the Record at the specified index.</p>

<p>The index is effected by filtering.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>index: <code class="code">Js.number Js.t</code>
    <p>The index of the Record to find.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.t</code>
    <p>The Record at the passed index. Returns undefined if not found.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetById"><span class="keyword">method</span> getById</span> : <code class="type">'s. 's Js.t -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t Js.meth</code></pre><div class="info">
<p>Get the Record with the specified id.</p>

<p>This method is not effected by filtering, lookup will be performed from all records
inside the store, filtered or not.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>id: <code class="code">_ Js.t</code>
    <p>The id of the Record to find.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.t</code>
    <p>The Record with the passed id. Returns null if not found.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetCount"><span class="keyword">method</span> getCount</span> : <code class="type">Js.number Js.t Js.meth</code></pre><div class="info">
<p>Gets the number of records in store.</p>

<p>If using paging, this may not be the total size of the dataset. If the data object
used by the Reader contains the dataset size, then the <a href="#!/api/Ext.data.Store-method-getTotalCount" rel="Ext.data.Store-method-getTotalCount" class="docClass">getTotalCount</a> function returns
the dataset size.  <strong>Note</strong>: see the Important note in <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a>.</p>

<p>When store is filtered, it's the number of records matching the filter.</p> 
<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code>
    <p>The number of Records in the Store.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetGroupString"><span class="keyword">method</span> getGroupString</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t -> Js.js_string Js.t Js.meth</code></pre><div class="info">
<p>Returns the string to group on for a given model instance. The default implementation of this method returns
the model's <a href="#!/api/Ext.data.Store-cfg-groupField" rel="Ext.data.Store-cfg-groupField" class="docClass">groupField</a>, but this can be overridden to group by an arbitrary string. For example, to
group by the first letter of a model's 'name' field, use the following code:</p>

<pre><code><a href="#!/api/Ext-method-create" rel="Ext-method-create" class="docClass">Ext.create</a>('<a href="#!/api/Ext.data.Store" rel="Ext.data.Store" class="docClass">Ext.data.Store</a>', {
    groupDir: 'ASC',
    getGroupString: function(instance) {
        return instance.get('name')[0];
    }
});
</code></pre> 
<p>

    <b>Parameters</b>:
    <ul>
<li>instance: <code class="code">Ext_data_Model.t Js.t</code>
    <p>The model instance</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.js_string Js.t</code>
    <p>The string to compare when forming groups</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetGroups"><span class="keyword">method</span> getGroups</span> : <code class="type">'t. Js.js_string Js.t Js.optdef -> 't Js.t Js.meth</code></pre><div class="info">
<p>Returns an array containing the result of applying grouping to the records in this store.
See <a href="#!/api/Ext.data.Store-cfg-groupField" rel="Ext.data.Store-cfg-groupField" class="docClass">groupField</a>, <a href="#!/api/Ext.data.Store-cfg-groupDir" rel="Ext.data.Store-cfg-groupDir" class="docClass">groupDir</a> and <a href="#!/api/Ext.data.Store-method-getGroupString" rel="Ext.data.Store-method-getGroupString" class="docClass">getGroupString</a>. Example for a store
containing records with a color field:</p>

<pre><code>var myStore = <a href="#!/api/Ext-method-create" rel="Ext-method-create" class="docClass">Ext.create</a>('<a href="#!/api/Ext.data.Store" rel="Ext.data.Store" class="docClass">Ext.data.Store</a>', {
    groupField: 'color',
    groupDir  : 'DESC'
});

myStore.getGroups(); // returns:
[
    {
        name: 'yellow',
        children: [
            // all records where the color field is 'yellow'
        ]
    },
    {
        name: 'red',
        children: [
            // all records where the color field is 'red'
        ]
    }
]
</code></pre>

<p>Group contents are effected by filtering.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>groupName: <code class="code">Js.js_string Js.t</code> (optional)
    <p>Pass in an optional groupName argument to access a specific
group as defined by <a href="#!/api/Ext.data.Store-method-getGroupString" rel="Ext.data.Store-method-getGroupString" class="docClass">getGroupString</a>.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code> <p>The grouped data</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetNewRecords"><span class="keyword">method</span> getNewRecords</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>inherit docs</p>

<p>Returns all Model instances that are either currently a phantom (e.g. have no id), or have an ID but have not
yet been saved on this Store (this happens when adding a non-phantom record from another Store into this one)</p> 
<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>The Model instances</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetPageFromRecordIndex"><span class="keyword">method</span> getPageFromRecordIndex</span> : <code class="type">Js.number Js.t -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Determines the page from a record index</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>index: <code class="code">Js.number Js.t</code>
    <p>The record index</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>The page the record belongs to</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetRange"><span class="keyword">method</span> getRange</span> : <code class="type">Js.number Js.t Js.optdef -><br>       Js.number Js.t Js.optdef -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>Returns a range of Records between specified indices.</p>

<p>This method is effected by filtering.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>startIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The starting index</p> 
     Defaults to: 0
    </li>
<li>endIndex: <code class="code">Js.number Js.t</code> (optional)
    <p>The ending index. Defaults to the last Record in the Store.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>An array of Records</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetTotalCount"><span class="keyword">method</span> getTotalCount</span> : <code class="type">Js.number Js.t Js.meth</code></pre><div class="info">
<p>Returns the total number of <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Model</a> instances that the <a href="#!/api/Ext.data.proxy.Proxy" rel="Ext.data.proxy.Proxy" class="docClass">Proxy</a>
indicates exist. This will usually differ from <a href="#!/api/Ext.data.Store-method-getCount" rel="Ext.data.Store-method-getCount" class="docClass">getCount</a> when using paging - getCount returns the
number of records loaded into the Store at the moment, getTotalCount returns the number of records that
could be loaded into the Store if the Store contained all data</p> 
<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code>
    <p>The total number of Model instances available via the Proxy. 0 returned if
no value has been set via the reader.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgetUpdatedRecords"><span class="keyword">method</span> getUpdatedRecords</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>inherit docs</p>

<p>Returns all Model instances that have been updated in the Store but not yet synchronized with the Proxy</p> 
<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>The updated Model instances</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODgroup"><span class="keyword">method</span> group</span> : <code class="type">'u. 'u Js.t -> Js.js_string Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Groups data inside the store.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>groupers: <code class="code">_ Js.t</code>
    <p>Either a string name of one of the fields in this Store's
configured <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Model</a>, or an Array of grouper configurations.</p> 
    </li>
<li>direction: <code class="code">Js.js_string Js.t</code> (optional)
    <p>The overall direction to group the data by.</p> 
     Defaults to: "ASC"
    </li>
</ul>
<br>
</div>
<pre><span id="METHODguaranteeRange"><span class="keyword">method</span> guaranteeRange</span> : <code class="type">'v 'w 'x 'y. 'v Js.t -> 'w Js.t -> 'x Js.t -> 'y Js.t -> unit Js.meth</code></pre><div class="info">
<p>Guarantee a specific range, this will load the store with a range (that
must be the pageSize or smaller) and take care of any loading that may
be necessary.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>start: <code class="code">_ Js.t</code>
    </li>
<li>_end: <code class="code">_ Js.t</code>
    </li>
<li>cb: <code class="code">_ Js.t</code>
    </li>
<li>scope: <code class="code">_ Js.t</code>
    </li>
</ul>
<br>
</div>
<pre><span id="METHODindexOf"><span class="keyword">method</span> indexOf</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Get the index of the record within the store.</p>

<p>When store is filtered, records outside of filter will not be found.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>record: <code class="code">Ext_data_Model.t Js.t</code>
    <p>The <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Ext.data.Model</a> object to find.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code>
    <p>The index of the passed Record. Returns -1 if not found.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODindexOfId"><span class="keyword">method</span> indexOfId</span> : <code class="type">Js.js_string Js.t -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Get the index within the store of the Record with the passed id.</p>

<p>Like <a href="#!/api/Ext.data.Store-method-indexOf" rel="Ext.data.Store-method-indexOf" class="docClass">indexOf</a>, this method is effected by filtering.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>id: <code class="code">Js.js_string Js.t</code>
    <p>The id of the Record to find.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code>
    <p>The index of the Record. Returns -1 if not found.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODindexOfTotal"><span class="keyword">method</span> indexOfTotal</span> : <code class="type"><a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.t -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Get the index within the entire dataset. From 0 to the totalCount.</p>

<p>Like <a href="#!/api/Ext.data.Store-method-indexOf" rel="Ext.data.Store-method-indexOf" class="docClass">indexOf</a>, this method is effected by filtering.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>record: <code class="code">Ext_data_Model.t Js.t</code>
    <p>The <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Ext.data.Model</a> object to find.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code>
    <p>The index of the passed Record. Returns -1 if not found.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODinsert"><span class="keyword">method</span> insert</span> : <code class="type">Js.number Js.t -> <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t -> unit Js.meth</code></pre><div class="info">
<p>Inserts Model instances into the Store at the given index and fires the <a href="#!/api/Ext.data.Store-event-add" rel="Ext.data.Store-event-add" class="docClass">add</a> event.
See also <a href="#!/api/Ext.data.Store-method-add" rel="Ext.data.Store-method-add" class="docClass">add</a>.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>index: <code class="code">Js.number Js.t</code>
    <p>The start index at which to insert the passed Records.</p> 
    </li>
<li>records: <code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>An Array of <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Ext.data.Model</a> objects to add to the store.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODisFiltered"><span class="keyword">method</span> isFiltered</span> : <code class="type">bool Js.t Js.meth</code></pre><div class="info">
<p>Returns true if this store is currently filtered</p> <br>
</div>
<pre><span id="METHODisGrouped"><span class="keyword">method</span> isGrouped</span> : <code class="type">bool Js.t Js.meth</code></pre><div class="info">
<p>Checks if the store is currently grouped</p> 
<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">bool Js.t</code> <p>True if the store is grouped.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODlast"><span class="keyword">method</span> last</span> : <code class="type">'z. bool Js.t Js.optdef -> 'z Js.t Js.meth</code></pre><div class="info">
<p>Convenience function for getting the last model instance in the store.</p>

<p>When store is filtered, will return last item within the filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the last record being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code>
    <p>The last model instance in the store, or undefined</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODload_store"><span class="keyword">method</span> load_store</span> : <code class="type">'a1. 'a1 Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Loads data into the Store via the configured <a href="#!/api/Ext.data.Store-cfg-proxy" rel="Ext.data.Store-cfg-proxy" class="docClass">proxy</a>. This uses the Proxy to make an
asynchronous call to whatever storage backend the Proxy uses, automatically adding the retrieved
instances into the Store and calling an optional callback if required. Example usage:</p>

<pre><code>store.load({
    scope: this,
    callback: function(records, operation, success) {
        // the <a href="#!/api/Ext.data.Operation" rel="Ext.data.Operation" class="docClass">operation</a> object
        // contains all of the details of the load operation
        console.log(records);
    }
});
</code></pre>

<p>If the callback scope does not need to be set, a function can simply be passed:</p>

<pre><code>store.load(function(records, operation, success) {
    console.log('loaded records');
});
</code></pre> 
<p>

    <b>Parameters</b>:
    <ul>
<li>options: <code class="code">_ Js.t</code> (optional)
    <p>config object, passed into the <a href="#!/api/Ext.data.Operation" rel="Ext.data.Operation" class="docClass">Ext.data.Operation</a> object before loading.
Additionally <code>addRecords: true</code> can be specified to add these records to the existing records, default is
to remove the Store's existing records first.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODloadData"><span class="keyword">method</span> loadData</span> : <code class="type">'b1. 'b1 Js.t -> bool Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Loads an array of data straight into the Store.</p>

<p>Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
processed by a reader). If your data requires processing to decode the data structure, use a
<a href="#!/api/Ext.data.proxy.Memory" rel="Ext.data.proxy.Memory" class="docClass">MemoryProxy</a> instead.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>data: <code class="code">_ Js.t</code>
    <p>Array of data to load. Any non-model instances will be cast
into model instances first.</p> 
    </li>
<li>append: <code class="code">bool Js.t</code> (optional)
    <p>True to add the records to the existing records in the store, false
to remove the old ones first.</p> 
     Defaults to: false
    </li>
</ul>
<br>
</div>
<pre><span id="METHODloadPage"><span class="keyword">method</span> loadPage</span> : <code class="type">'c1. Js.number Js.t -> 'c1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
load operation, passing in calculated 'start' and 'limit' params</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>page: <code class="code">Js.number Js.t</code>
    <p>The number of the page to load</p> 
    </li>
<li>options: <code class="code">_ Js.t</code>
    <p>See options for <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a></p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODloadRawData"><span class="keyword">method</span> loadRawData</span> : <code class="type">'d1. 'd1 Js.t Js.js_array Js.t -> bool Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Loads data via the bound Proxy's reader</p>

<p>Use this method if you are attempting to load data and want to utilize the configured data reader.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>data: <code class="code">_ Js.t Js.js_array Js.t</code>
    <p>The full JSON object you'd like to load into the Data store.</p> 
    </li>
<li>append: <code class="code">bool Js.t</code> (optional)
    <p>True to add the records to the existing records in the store, false
to remove the old ones first.</p> 
     Defaults to: false
    </li>
</ul>
<br>
</div>
<pre><span id="METHODloadRecords"><span class="keyword">method</span> loadRecords</span> : <code class="type">'e1. <a href="Ext_data_Model.t-c.html">Ext_data_Model.t</a> Js.js_array Js.t -> 'e1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Loads an array of <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">model</a> instances into the store, fires the datachanged event. This should only usually
be called internally when loading from the <a href="#!/api/Ext.data.proxy.Proxy" rel="Ext.data.proxy.Proxy" class="docClass">Proxy</a>, when adding records manually use <a href="#!/api/Ext.data.Store-method-add" rel="Ext.data.Store-method-add" class="docClass">add</a> instead</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>records: <code class="code">Ext_data_Model.t Js.js_array Js.t</code>
    <p>The array of records to load</p> 
    </li>
<li>options: <code class="code">_ Js.t</code>
    </li>
</ul>
<br>
</div>
<pre><span id="METHODmax"><span class="keyword">method</span> max</span> : <code class="type">'f1. Js.js_string Js.t -> bool Js.t Js.optdef -> 'f1 Js.t Js.meth</code></pre><div class="info">
<p>Gets the maximum value in the store.</p>

<p>When store is filtered, only items within the filter are aggregated.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>field: <code class="code">Js.js_string Js.t</code>
    <p>The field in each record</p> 
    </li>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the maximum in the group being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code>
    <p>The maximum value, if no items exist, undefined.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODmin"><span class="keyword">method</span> min</span> : <code class="type">'g1. Js.js_string Js.t -> bool Js.t Js.optdef -> 'g1 Js.t Js.meth</code></pre><div class="info">
<p>Gets the minimum value in the store.</p>

<p>When store is filtered, only items within the filter are aggregated.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>field: <code class="code">Js.js_string Js.t</code>
    <p>The field in each record</p> 
    </li>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the minimum in the group being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">_ Js.t</code>
    <p>The minimum value, if no items exist, undefined.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODnextPage"><span class="keyword">method</span> nextPage</span> : <code class="type">'h1. 'h1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Loads the next 'page' in the current data set</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>options: <code class="code">_ Js.t</code>
    <p>See options for <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a></p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODprefetch"><span class="keyword">method</span> prefetch</span> : <code class="type">'i1. 'i1 Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Prefetches data into the store using its configured <a href="#!/api/Ext.data.Store-cfg-proxy" rel="Ext.data.Store-cfg-proxy" class="docClass">proxy</a>.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>options: <code class="code">_ Js.t</code> (optional)
    <p>config object, passed into the <a href="#!/api/Ext.data.Operation" rel="Ext.data.Operation" class="docClass">Ext.data.Operation</a> object before loading.
See <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a></p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODprefetchPage"><span class="keyword">method</span> prefetchPage</span> : <code class="type">'j1. Js.number Js.t -> 'j1 Js.t Js.optdef -> unit Js.meth</code></pre><div class="info">
<p>Prefetches a page of data.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>page: <code class="code">Js.number Js.t</code>
    <p>The page to prefetch</p> 
    </li>
<li>options: <code class="code">_ Js.t</code> (optional)
    <p>config object, passed into the <a href="#!/api/Ext.data.Operation" rel="Ext.data.Operation" class="docClass">Ext.data.Operation</a> object before loading.
See <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a></p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODprefetchRange"><span class="keyword">method</span> prefetchRange</span> : <code class="type">'k1 'l1. 'k1 Js.t -> 'l1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Ensures that the specified range of rows is present in the cache.</p>

<p>Converts the row range to a page range and then only load pages which are not already
present in the page cache.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>start: <code class="code">_ Js.t</code>
    </li>
<li>_end: <code class="code">_ Js.t</code>
    </li>
</ul>
<br>
</div>
<pre><span id="METHODpreviousPage"><span class="keyword">method</span> previousPage</span> : <code class="type">'m1. 'm1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Loads the previous 'page' in the current data set</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>options: <code class="code">_ Js.t</code>
    <p>See options for <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a></p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODquery"><span class="keyword">method</span> query</span> : <code class="type">'n1.<br>         Js.js_string Js.t -><br>         'n1 Js.t -><br>         bool Js.t Js.optdef -><br>         bool Js.t Js.optdef -><br>         bool Js.t Js.optdef -> <a href="Ext_util_MixedCollection.t-c.html">Ext_util_MixedCollection.t</a> Js.t Js.meth</code></pre><div class="info">
<p>Query all the cached records in this Store by name/value pair.
The parameters will be used to generated a filter function that is given
to the queryBy method.</p>

<p>This method compliments queryBy by generating the query function automatically.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>property: <code class="code">Js.js_string Js.t</code>
    <p>The property to create the filter function for</p> 
    </li>
<li>value: <code class="code">_ Js.t</code>
    <p>The string/regex to compare the property value to</p> 
    </li>
<li>anyMatch: <code class="code">bool Js.t</code> (optional)
    <p>True if we don't care if the filter value is not the full value.</p> 
     Defaults to: false
    </li>
<li>caseSensitive: <code class="code">bool Js.t</code> (optional)
    <p>True to create a case-sensitive regex.</p> 
     Defaults to: false
    </li>
<li>exactMatch: <code class="code">bool Js.t</code> (optional)
    <p>True to force exact match (^ and $ characters added to the regex).
Ignored if anyMatch is true.</p> 
     Defaults to: false
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_util_MixedCollection.t Js.t</code>
    <p>Returns an <a href="#!/api/Ext.util.MixedCollection" rel="Ext.util.MixedCollection" class="docClass">Ext.util.MixedCollection</a> of the matched records</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODqueryBy"><span class="keyword">method</span> queryBy</span> : <code class="type">'o1 'p1.<br>         'o1 Js.callback -><br>         'p1 Js.t Js.optdef -> <a href="Ext_util_MixedCollection.t-c.html">Ext_util_MixedCollection.t</a> Js.t Js.meth</code></pre><div class="info">
<p>Query all the cached records in this Store using a filtering function. The specified function
will be called with each record in this Store. If the function returns <code>true</code> the record is
included in the results.</p>

<p>This method is not effected by filtering, it will always look from all records inside the store
no matter if filter is applied or not.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>fn: <code class="code">_ Js.callback</code>
    <p>The function to be called. It will be passed the following parameters:</p> 
    </li>
<li>scope: <code class="code">_ Js.t</code> (optional)
    <p>The scope (this reference) in which the function is executed
Defaults to this Store.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Ext_util_MixedCollection.t Js.t</code>
    <p>Returns an <a href="#!/api/Ext.util.MixedCollection" rel="Ext.util.MixedCollection" class="docClass">Ext.util.MixedCollection</a> of the matched records</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODrejectChanges"><span class="keyword">method</span> rejectChanges</span> : <code class="type">unit Js.meth</code></pre><div class="info">
<p><a href="#!/api/Ext.data.Model-method-reject" rel="Ext.data.Model-method-reject" class="docClass">Rejects</a> outstanding changes on all <a href="#!/api/Ext.data.Store-method-getModifiedRecords" rel="Ext.data.Store-method-getModifiedRecords" class="docClass">modified records</a>
and re-insert any records that were removed locally. Any phantom records will be removed.</p> <br>
</div>
<pre><span id="METHODreload"><span class="keyword">method</span> reload</span> : <code class="type">'q1. 'q1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Reloads the store using the last options passed to the <a href="#!/api/Ext.data.Store-method-load" rel="Ext.data.Store-method-load" class="docClass">load</a> method.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>options: <code class="code">_ Js.t</code>
    <p>A config object which contains options which may override the options passed to the previous load call.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODremove"><span class="keyword">method</span> remove</span> : <code class="type">'r1. 'r1 Js.t -> unit Js.meth</code></pre><div class="info">
<p>Removes the given record from the Store, firing the 'remove' event for each instance that is removed,
plus a single 'datachanged' event after removal.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>records: <code class="code">_ Js.t</code>
    <p>Model instance or array of instances to remove.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODremoveAll_bool"><span class="keyword">method</span> removeAll_bool</span> : <code class="type">bool Js.t -> unit Js.meth</code></pre><div class="info">
<p>Removes all items from the store.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>silent: <code class="code">bool Js.t</code>
    <p>Prevent the <code>clear</code> event from being fired.</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODremoveAt"><span class="keyword">method</span> removeAt</span> : <code class="type">Js.number Js.t -> unit Js.meth</code></pre><div class="info">
<p>Removes the model instance at the given index</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>index: <code class="code">Js.number Js.t</code> <p>The record index</p> 
    </li>
</ul>
<br>
</div>
<pre><span id="METHODsort"><span class="keyword">method</span> sort</span> : <code class="type">'s1.<br>         's1 Js.t Js.optdef -><br>         Js.js_string Js.t Js.optdef -> <a href="Ext_util_Sorter.t-c.html">Ext_util_Sorter.t</a> Js.js_array Js.t Js.meth</code></pre><div class="info">
<p>because prefetchData is stored by index
this invalidates all of the prefetchedData</p>

<p>Sorts the data in the Store by one or more of its properties. Example usage:</p>

<pre><code>//sort by a single field
myStore.sort('myField', 'DESC');

//sorting by multiple fields
myStore.sort([
    {
        property : 'age',
        direction: 'ASC'
    },
    {
        property : 'name',
        direction: 'DESC'
    }
]);
</code></pre>

<p>Internally, Store converts the passed arguments into an array of <a href="#!/api/Ext.util.Sorter" rel="Ext.util.Sorter" class="docClass">Ext.util.Sorter</a> instances, and delegates
the actual sorting to its internal <a href="#!/api/Ext.util.MixedCollection" rel="Ext.util.MixedCollection" class="docClass">Ext.util.MixedCollection</a>.</p>

<p>When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:</p>

<pre><code>store.sort('myField');
store.sort('myField');
</code></pre>

<p>Is equivalent to this code, because Store handles the toggling automatically:</p>

<pre><code>store.sort('myField', 'ASC');
store.sort('myField', 'DESC');
</code></pre> 
<p>

    <b>Parameters</b>:
    <ul>
<li>sorters: <code class="code">_ Js.t</code> (optional)
    <p>Either a string name of one of the fields in this Store's configured
<a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">Model</a>, or an array of sorter configurations.</p> 
    </li>
<li>direction: <code class="code">Js.js_string Js.t</code> (optional)
    <p>The overall direction to sort the data by.</p> 
     Defaults to: "ASC"
    </li>
</ul>
<br>
</div>
<pre><span id="METHODsum"><span class="keyword">method</span> sum</span> : <code class="type">Js.js_string Js.t -> bool Js.t Js.optdef -> Js.number Js.t Js.meth</code></pre><div class="info">
<p>Sums the value of <code>property</code> for each <a href="#!/api/Ext.data.Model" rel="Ext.data.Model" class="docClass">record</a> between <code>start</code>
and <code>end</code> and returns the result.</p>

<p>When store is filtered, only sums items within the filter.</p> 
<p>

    <b>Parameters</b>:
    <ul>
<li>field: <code class="code">Js.js_string Js.t</code>
    <p>A field in each record</p> 
    </li>
<li>grouped: <code class="code">bool Js.t</code> (optional)
    <p>True to perform the operation for each group
in the store. The value returned will be an object literal with the key being the group
name and the sum for that group being the value. The grouped parameter is only honored if
the store has a groupField.</p> 
    </li>
</ul>

<p>

    <b>Returns</b>:
    <ul>
<li><code class="code">Js.number Js.t</code> <p>The sum</p> 
    </li>
</ul>
<br>
</div>
</body></html>